#!/usr/bin/python@PY_VERSION@
#
# ovirt-engine-setup -- ovirt engine setup
#
# Copyright oVirt Authors
# SPDX-License-Identifier: Apache-2.0
#
#


import sys
import os
import time
import optparse
import gettext
import glob


from otopi import common
from otopi import constants as otopicons


if sys.version_info[0] >= 3:
    import builtins
    setattr(builtins, 'unicode', str)
else:
    import ConfigParser
    sys.modules['configparser'] = ConfigParser
    import __builtin__
    sys.modules['builtins'] = __builtin__

import configparser

sys.path.append(os.path.dirname(
    os.path.dirname(os.path.realpath(sys.argv[0]))
))


from ovirt_engine_setup import constants as osetupcons
from ovirt_engine_setup import util as osetuputil
from ovirt_engine_setup.engine import constants as oenginecons


_ = lambda m: gettext.dgettext(message=m, domain='ovirt-engine-setup')


def tolist(s):
    if not s:
        return []
    return [e.strip() for e in s.split(',')]


def get_setup_packages():
    setup_packages = []
    engine_setup_packages = [oenginecons.Const.ENGINE_PACKAGE_SETUP_NAME]

    engine_setup_config = configparser.ConfigParser()
    engine_setup_config.optionxform = str
    configs = []
    configFile = osetupcons.FileLocations.OVIRT_OVIRT_SETUP_CONFIG_FILE
    configDir = '%s.d' % configFile
    if os.path.exists(configFile):
        configs.append(configFile)
    configs += sorted(
        glob.glob(
            os.path.join(configDir, '*.conf')
        )
    )
    engine_setup_config.read(configs)

    def get_packages(section, key):
        return tolist(
            common.parseTypedValue(
                engine_setup_config.get(section, key)
            )
        )

    for section in (
        otopicons.Const.CONFIG_SECTION_DEFAULT,
        otopicons.Const.CONFIG_SECTION_INIT,
        otopicons.Const.CONFIG_SECTION_OVERRIDE,
        otopicons.Const.CONFIG_SECTION_ENFORCE
    ):
        if engine_setup_config.has_section(section):
            if engine_setup_config.has_option(
                section,
                oenginecons.RPMDistroEnv.ENGINE_SETUP_PACKAGES
            ):
                engine_setup_packages = get_packages(
                    section,
                    oenginecons.RPMDistroEnv.ENGINE_SETUP_PACKAGES
                )
            if engine_setup_config.has_option(
                section,
                osetupcons.RPMDistroEnv.PACKAGES_SETUP
            ):
                setup_packages = get_packages(
                    section,
                    osetupcons.RPMDistroEnv.PACKAGES_SETUP
                )
    setup_packages.extend(engine_setup_packages)
    return setup_packages


def main():
    parser = optparse.OptionParser(
        usage=_('Usage: %prog [options]'),
    )
    parser.add_option(
        '-q', '--quiet',
        dest='quiet',
        action='store_true',
        default=False,
        help=_('quiet mode'),
    )
    (options, args) = parser.parse_args()
    setup_packages = get_setup_packages()

    try:
        if not osetuputil.is_ovirt_packaging_supported_distro():
            raise RuntimeError(_('Unsupported distribution'))

        exit = 1

        PM, MiniPM, MiniPMSinkBase = osetuputil.getPackageManager()

        class _MyMiniPMSink(MiniPMSinkBase):

            KEEPALIVE_INTERVAL = 60

            def __init__(self):
                super(_MyMiniPMSink, self).__init__()
                self._stream = os.dup(sys.stdout.fileno())
                self._touch()

            def __del__(self):
                os.close(self._stream)

            def _touch(self):
                self._last = time.time()

            def verbose(self, msg):
                super(_MyMiniPMSink, self).verbose(msg)
                os.write(self._stream, ('VERB: %s\n' % msg).encode('utf-8'))

            def info(self, msg):
                super(_MyMiniPMSink, self).info(msg)
                self._touch()
                os.write(self._stream, ('OK:   %s\n' % msg).encode('utf-8'))

            def error(self, msg):
                super(_MyMiniPMSink, self).error(msg)
                self._touch()
                os.write(self._stream, ('FAIL: %s\n' % msg).encode('utf-8'))

            def keepAlive(self, msg):
                super(_MyMiniPMSink, self).keepAlive(msg)
                if time.time() - self._last >= \
                        self.KEEPALIVE_INTERVAL:
                    self.info(msg)

            def askForGPGKeyImport(self, userid, hexkeyid):
                os.write(
                    self._stream,
                    (
                        'APPROVE-GPG: %s-%s\n' % (userid, hexkeyid)
                    ).encode('utf-8')
                )
                return True

        mpm = MiniPM(
            sink=(
                None if options.quiet
                else _MyMiniPMSink()
            ),
            disabledPlugins=('versionlock',),
        )
        with mpm.transaction():
            mpm.update(
                packages=setup_packages,
            )
            if mpm.buildTransaction():
                exit = 0

        if not options.quiet:
            sys.stdout.write(
                '%s\n' % (
                    _('Upgrade available.') if exit == 0
                    else _(
                        'No upgrade is available for the setup package.\n'
                        'Please note that system may not be up to date '
                        'if engine-setup wasn\'t executed after yum update.'
                    )
                )
            )
        sys.exit(exit)

    except Exception as e:
        if not options.quiet:
            sys.stderr.write(
                _('Error: {error}\n').format(
                    error=e,
                )
            )
        sys.exit(2)


if __name__ == '__main__':
    main()


# vim: expandtab tabstop=4 shiftwidth=4
